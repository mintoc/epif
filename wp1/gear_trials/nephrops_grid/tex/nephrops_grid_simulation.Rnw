%% knit("nephrops_grid_simulation.Rnw")

\documentclass[12pt]{article}
\usepackage{times}
\usepackage{hyperref}
\usepackage{natbib}
\hypersetup{pdfpagemode=UseNone} % don't show bookmarks on initial view
\hypersetup{colorlinks, urlcolor={blue}}

% revise margins
\setlength{\headheight}{0.0in}
\setlength{\topmargin}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\textheight}{8.65in}
\setlength{\footskip}{0.35in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\textwidth}{6.5in}

\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}

\title{Simulations to assist with \emph{Nephrops} quad-rig trial designs}
\author{For discussion only}
\date{}

\begin{document}

<<echo=FALSE>>=
library(knitr)
opts_chunk$set(size="footnotesize")
## set the working directory
##setwd('../tex'); 
@

\maketitle

\section{Summary}
A simulation model for abundance-at-length and fishing of \emph{Nephrops} in the Western Irish Sea is developed for the specific purpose of assisting in survey design. The abundance simulation is relatively straightforward, the fishing gear effects are more involved and should only be considered indicative at present. Given time constraints, issues may have arisen with the code so extreme caution is requested in interpreting these results. It is envisaged that the framework will form the basis of further trial designs.  
\section{Simulation setup}
We follow the general model of \citet{Millar:Fryer:1999} to generate catches from three processes:
\begin{enumerate}
 \item Abundance;
 \item Relative fishing intensity;
 \item Contact-selection.
\end{enumerate}

%% TRUE POPULATION
\subsection{Abundance-at-length of \emph{Nephrops}}
The purpose of this section is to simulate a true underlying population of \emph{Nephrops} in terms of abundance-at-length.\\
As the ageing of \emph{Nephrops} is unclear at the moment we assume that there are four components (possibly age classes) present. This can be changed subsequently. First set the population lengths for each component

<<eval = TRUE>>=
## median carapace lengths for 4 components
mu.l <- c(10, 15, 20, 25)

## cv of carapace length for each component
cv.l <- 0.3

## proportion of the population composed of given component
p <- c(0.4, 0.3, 0.2, 0.1)

@ 

Plot the distribution of simulated lengths on the grounds (Figure~\ref{fig:popl}).
<<popl, eval = TRUE, fig.align = "center", fig.cap = "Simulated length distribution of the population of \\emph{Nephrops} on the grounds.", fig.width = 6, fig.height = 5>>=
## vector of lengths
length.vec <- 0:60

## densities of each component
d1 <- p[1] * dlnorm(length.vec, log(mu.l[1]), sdlog = cv.l)
d2 <- p[2] * dlnorm(length.vec, log(mu.l[2]), sdlog = cv.l)
d3 <- p[3] * dlnorm(length.vec, log(mu.l[3]), sdlog = cv.l)
d4 <- p[4] * dlnorm(length.vec, log(mu.l[4]), sdlog = cv.l)

d <- rbind(d1, d2, d3, d4)

dsum <- apply(d, 2, sum)

## plot
plot(length.vec, dsum, type = "n", xlab = "Carapace length (mm)", 
     ylab = "Distribution density", bty = "L")

matlines(length.vec, t(d), col = "purple", lty = 1)

lines(length.vec, apply(d, 2, sum), col = "forestgreen", lwd = 1.5)

legend("topright", legend = c("Component (age) distribution", "Overall distribution"), 
       lty = 1, lwd = c(1, 1.5), col = c("purple", "forestgreen"), bty = "n")

@
We first assume that the local length distribution (on the grounds) is the same as the population length distribution (Western Irish Sea area). To convert the length distribution to the numbers at length $n_l$ we approximate the overall distribution (Figure~\ref{fig:popl}) by one mm bins, the proportion of the total area occupied by each bin is then used to generate the population counts by length bin. First the proportion of the population per length bin is simulated

<<eval = TRUE>>=
## approximate the area under the overall distribution
library(flux)
midpoints <- (length.vec[-length(length.vec)] + length.vec[-1])/2

nm <- length(midpoints)

## proportion of population per length class
prop.l <- rep(NA, nm)

for(i in 1:(length(length.vec) - 1)){
  prop.l[i] <- auc(x = length.vec[i:(i + 1)], y = dsum[i:(i + 1)])
}

sum(prop.l)
## close to 1, difference due to approximation
@ 

The proportion of the population per length bin is then multiplied by the estimated abundance of $4.6 \times 10^9$ burrows \citep{Ligas:etal:survey:2014} to obtain the distribution of numbers at length (Figure~\ref{fig:abundl}).

<<abundl, eval = TRUE, fig.align = "center", fig.cap = "Simulated abundance-at-length of \\emph{Nephrops} on the grounds.", fig.width = 6, fig.height = 5>>=
n <- 4.6e9

nl <- prop.l * n

barplot(nl, space = 0, col = "lightgrey", ylab = "Abundance (number of burrows)", 
        xlab = "Length-class (cm)")

axis(side = 1, at = seq(0, 60, by = 10))

@
It may be necessary to alter the length distribution and abundance spatially to truly reflect the population on the grounds.


\subsection{Contacts with gear}
The footline length on the Celtic Warrior II trials on the Smalls was 38m - assuming the footline takes on a semi-circle during fishing (revise to catenary or similar - think about how this influences the face of each rig also) implies $2 \pi r  = 2 \times 38m$ and so the radius $r  = 38m/\pi$ and the diameter (fishing contact width) is $2 \times 38m/\pi \approx 24.2m$. Based on a towing speed of 3 knots ($\approx$ 5.6km.h$^{-1}$), the area covered per hour is assumed to be 5.6km.h$^{-1}$ $\times$ 0.0242km $\approx$ 0.14km$^2$.h$^{-1}$.

<<eval = TRUE>>=
fishing.width <- 0.0242 ## km

speed <- 5.6 ## km/h

area.ph <- round(fishing.width * speed, 2) ## km^2/hour

@

The adjusted mean density is estimated as \Sexpr{(burrow.dens <- 0.83)} burrows.m$^{-2}$ \citep{Ligas:etal:survey:2014}. Therefore, the simulated number of burrows covered per hour is \Sexpr{area.ph}km$^2$.h$^{-1}$ $\times$ \Sexpr{burrow.dens * 1e6}km$^{-2}$ $=$ \Sexpr{(burrows.ph <- area.ph * burrow.dens * 1e6)}.h$^{-1}$.\\ 
<<eval = TRUE>>=
burrow.dens <- 0.83 * 1e6

(burrows.ph <- area.ph * burrow.dens)

@

Assuming a proportion of the \emph{Nephrops} in the burrows covered will come out of the burrows and contact the net (revise), we can simulate the numbers contacting the net per hour. 
<<eval = TRUE>>=

contact.prop <- 0.2

hours.towed <- 1

(n.contact <- contact.prop * hours.towed * burrows.ph)
@ 

This can then be converted to the numbers at length contacting the net per hour, assuming the probability of contact is equal across length classes.
<<eval = TRUE>>=

nl.contact <- n.contact/n * nl

@ 

We now have a very basic model \underline{linear} model for generating \emph{Nephrops} contacts with the net on the basis of the numbers of hours towed and density of burrows on the grounds. This could be considerably improved with further discussion and refinement but is assumed correct in the simulations below.

\subsection{Relative fishing intensity}
As in \citep{Millar:Fryer:1999}, the relative fishing intensity $p_j(l)$ is the probability that a fish of length $l$ contacts gear $j$ given that it has contacted the entire net. In a quad-rig, this is the probability that a \emph{Nephrops} entering the entire net contacts each of the rigs. The simplest assumption is that the relative fishing intensity is length-independent and equal across the gears $p_j(l) = 1/4$ (for quad-rig). But it is possible that asymmetries (e.g., door functioning), hydrodynamics, etc. make the probabilities of contact unequal across the nets. We simulate three relative fishing intensity scenarios, assuming length-independence of each:
\begin{enumerate}
  \item Equal relative fishing intensity $p_j(l) = 1/4$;
  \item Single net effect: relative fishing intensity of the second net (second in from port side) fishing twice as well as the others ($p_2(l) = 2/5, p_{1,3,4} = 1/5$).
  \item Simulated door effect: relative fishing intensity increasing from port to starboard with  ($p_1(l) = 1/10, p_2 = 2/10, p_3 = 3/10, p_4 = 4/10$). Note that the relative fishing intensity is drastic with the outermost starboard having four times the fishing intensity of the outermost port. This is unlikely in reality but is used in the simulations to exemplify the effects.
\end{enumerate}

<<eval = TRUE>>=
## relative fishing intensity
## scenario 1
p.rfi.1 <- rep(1/4, 4)

## scenario 2
p.rfi.2 <- c(1/5, 2/5, rep(1/5, 2))

## scenario 3
p.rfi.3 <- c(1/10, 2/10, 3/10, 4/10)

@ 

\subsection{Simulated contact selection $r_j(l)$}
We focus on a much-simplified analysis of the retention of the proportion of \emph{Nephrops} above and below the MLS retained in each cod-end. Given the priority of the cod-end we focus on that here but will add in grid selectivity on (Monday).

\subsubsection{Cod-end retention}
From trials conducted in the Danish fishery over two years, using commercial 90mm diamond mesh codend with 5mm double twine, \citet{Frandsen:etal:2010} estimated $L_{50, 2006} = 16.71, L_{50, 2007} = 18.35$ and $SR_{2006} = 14.71, SR_{2007} = 11.73$. We take an average of these parameters for the selectivity of the 90mm cod-end.

<<eval = TRUE>>=
l50.90mm <- (16.71 + 18.35) / 2

SR.90mm <- (14.71 + 11.73) / 2

@ 
For the other cod-ends we could not readily find information on the selectivity curves, we therefore assume that each 10mm change in the cod-end mesh size shifts the $L_{50}$ by 5mm, keeping the selectivity range constant (Figure~\ref{fig:codendsel}).

<<eval = TRUE>>=
delta <- 5 ## difference per 10mm

l50.100mm <- l50.90mm + delta
l50.80mm <- l50.90mm - delta
l50.70mm <- l50.90mm - 2 * delta

## all 
l50 <- c(l50.70mm, l50.80mm, l50.90mm, l50.100mm)
names(l50) <- c("70mm", "80mm", "90mm", "100mm")

## selectivity range
SR.100mm <- SR.80mm <- SR.70mm <- SR.90mm 

## all
SR <- c(SR.70mm, SR.80mm, SR.90mm, SR.100mm)
names(SR) <- c("70mm", "80mm", "90mm", "100mm")

@ 

<<codendsel, eval = TRUE, fig.align = "center", fig.cap = "Simulated cod-end selectivity curves. Based on diamond-mesh sizes as indicated in the legend.", fig.width = 5, fig.height = 5>>=
logist.sel <- function(x, l50, sr){
  plogis(2 * log(3) / sr * (x - l50))  
}

curve(logist.sel(x = x, l50 = l50.70mm, sr = SR.70mm), 
      from = 0, to = 60, xlab = "Carapace length (mm)",
      ylab = "Proportion retained in cod-end",
      bty = "L", ylim = c(0, 1))
curve(logist.sel(x = x, l50 = l50.80mm, sr = SR.80mm), 
      lty = 2, add = TRUE)
curve(logist.sel(x = x, l50 = l50.90mm, sr = SR.90mm), 
      lty = 3, add = TRUE)
curve(logist.sel(x = x, l50 = l50.100mm, sr = SR.100mm), 
      lty = 4, add = TRUE)
legend("bottomright", legend = c("70mm", "80mm", "90mm", "100mm"),
       lty = 1:4, bty = "n")

## matrix of cod-end retention at length by gear
rl.mat <- cbind(
            logist.sel(x = midpoints, l50 = l50.70mm, sr = SR.70mm),
            logist.sel(x = midpoints, l50 = l50.80mm, sr = SR.80mm),
            logist.sel(x = midpoints, l50 = l50.90mm, sr = SR.90mm),
            logist.sel(x = midpoints, l50 = l50.100mm, sr = SR.100mm)
            )
colnames(rl.mat) <- c("70mm", "80mm", "90mm", "100mm")

@

We do not include weight effects in the simulation here although these could be included by making the parameters of the selectivity curves a function of bulk weight.

\subsection{Net positions}
In a quad-rig with with 4 cod-end mesh sizes, there are 24 possible configurations of the positioning of the nets. To see what configuration gives the maximal difference of mesh sizes between adjacent nets, we can use the permuations.

<<eval = TRUE>>=
library(combinat)

perm.list <- permn(c(70, 80, 90, 100))

## calulate the differences between the mesh size
perm.diff <- unlist(lapply(perm.list, FUN = function(z){sum(abs(diff(z)))}))

perm.list[which.max(perm.diff)] ## reverse is also maximal difference

@

We use three net configurations in the simulations:

\begin{enumerate}
  \item Adjacent: 70, 80, 90, 100;
  \item Random: each haul random (completely impractical but useful for comparison);
  %\item Maximal difference: 90, 70, 100, 80.
  \item Non-adjacent: 70, 90, 80, 100.
\end{enumerate}

<<eval = TRUE>>=
net.position.adj <- c("70mm", "80mm", "90mm", "100mm")

net.position.nadj <- c("70mm", "90mm", "80mm", "100mm")
@ 

\section{Simulation}
The numbers retained in the cod-end per length class $l$ per haul $h$ per gear $j$ are simulated as \citep{Millar:Fryer:1999}:

\begin{equation}
n_{l, j, h} \sim \textnormal{Pois}(p_j \lambda_l r_j(l) e^{\varepsilon_h})
\label{eqn:generalmodel}
\end{equation}
where $\varepsilon_j$ is a haul effect representing unmeasured variables influence on the counts (e.g., some hauls have greater or lower numbers). We assume that this haul effect has a CV of 20\% (refine), corresponding to $\varepsilon_h \sim \textnormal{N}(0, 0.2^2)$. Equation~(\ref{eqn:generalmodel}) gives us the ability to simulate catches per net by haul. We can write a function that produces the expected data per haul

<<eval = TRUE>>=

sim.neph.data <- function(p.rfi, net.position, subs.ratio, CV.haul, hours.towed){
  ##---------------------------  
  ## p.rfi is the relative fishing intensity with names "70mm","80mm","90mm","100mm"
  ## net.position is the order of the nets, e.g., c("70mm","80mm","90mm","100mm")
  ## subs.ratio is the proportion of the catch sampled
  ## CV.haul is the coefficient of variation of the haul effect
  ## hours.towed: number of hourse towed
  ##---------------------------
  ## numbers contacting the net
  (n.contact <- contact.prop * hours.towed * burrows.ph)
  ## numbers contacting by length
  lambda.l <- n.contact/n * nl
  ## numbers contacting each of the gears
  nlj <- matrix(lambda.l) %*% t(matrix(p.rfi))
  colnames(nlj) <- net.position
  ## cod-end retention in order of net position
  r.l <- rl.mat[, net.position]  
  ## haul effect
  epsilon <- rnorm(1, 0, CV.haul)
  ##
  pois.mean <- nlj * r.l * exp(epsilon)
  ## numbers per net per length class
  nlh <- apply(pois.mean, 2, FUN = function(z){rpois(nm, lambda = z)})
  ## subsample
  for(i in 1:4){
    nlh.all <- rep(midpoints, times = nlh[,i])
    ## randomly choose from the total catch 
    n.neph <- length(nlh.all)
    sample.idx <- sample(1:n.neph, size = round(n.neph/2), replace = FALSE)
    neph.subsample <- nlh.all[sample.idx]
    assign(paste("neph.subsample", colnames(nlh)[i], sep = "."),
           neph.subsample)
    rm(neph.subsample)
  }
  ##
  binned.70mm <- table(cut(neph.subsample.70mm, breaks = length.vec))
  binned.80mm <- table(cut(neph.subsample.80mm, breaks = length.vec))
  binned.90mm <- table(cut(neph.subsample.90mm, breaks = length.vec))
  binned.100mm <- table(cut(neph.subsample.100mm, breaks = length.vec))
  ##
  haul.df <- data.frame(length = midpoints, 
                        "count.70mm" = as.numeric(binned.70mm),
                        "count.80mm" = as.numeric(binned.80mm),
                        "count.90mm" = as.numeric(binned.90mm),
                        "count.100mm" = as.numeric(binned.100mm)
                        )
  return(haul.df)
}

@ 

Test the function (Figure~\ref{fig:exsim}).

<<exsim, eval = TRUE, fig.align = "center", fig.cap = "Simulated sample numbers per length class by mesh size assuming equal fishing intensity.", fig.width = 6, fig.height = 5>>=

sim.haul <- sim.neph.data(p.rfi = p.rfi.1, 
                          net.position = c("70mm", "80mm", "90mm", "100mm"), 
                          subs.ratio = 0.2, 
                          CV.haul = 0.2, 
                          hours.towed = 2)

matplot(sim.haul[,1], sim.haul[, -1], pch = 1, xlab = "Carapace length (mm)", 
        ylab = "Measured number", bty = "L")
legend("topright", legend = c("70mm", "80mm", "90mm", "100mm"),
       pch = 1, col = 1:4, bty = "n")


@ 

\subsection{Simulation scenarios}
For the simulation scenarios we define the power as the power to detect a significant ($\alpha = 0.05$) difference in the number caught below the minimum landing size (20mm) by gear with the direction of the estimated counts being $70mm > 80mm > 90mm > 100mm$. \\

Generate the combinations of simulation scenarios

<<eval = TRUE>>=

sim.comb <- expand.grid(p.rfi = c("p.rfi.1","p.rfi.2","p.rfi.3"),
                        net.position = c("adjacent","random","non-adjacent"),
                        switch = c("no", "yes"),
                        stringsAsFactors = FALSE)

sim.comb$power <- NA

@ 


Run through the scenarios with 50 simulations per scenario

<<eval = FALSE>>=

nsim <- 50

for(i in 1:dim(sim.comb)[1]){
  print(i)
  sim.correct <- rep(NA, nsim)
  ##
  for(j in 1:nsim){
    ## get the net position
    if(sim.comb$net.position[i] == "adjacent"){
      net.position <- net.position.adj 
    }
      if(sim.comb$net.position[i] == "non-adjacent"){
        net.position <- net.position.nadj 
      }
    if(sim.comb$net.position[i] == "random"){
      net.position <- sample(c("70mm", "80mm", "90mm", "100mm"), 4)
    }
    ##
    nhauls <- 10
    haul.list <- lapply(1:nhauls, function(x){
      if(sim.comb$switch[i] == "yes" & x > 5){
        net.position <- rev(net.position) ## rotate the nets
      }
      ##print(net.position)
      dat <- sim.neph.data(p.rfi = get(sim.comb$p.rfi[i]), 
                           net.position = net.position, 
                           subs.ratio = 0.2, 
                           CV.haul = 0.2, 
                           hours.towed = 2)
      dat$HAULID <- x
      return(dat)
    })
    haul.data <- do.call(rbind, haul.list)
    ## subset for those under MLS
    mls.data <- haul.data[haul.data$length < 20, ]
    ## sum the counts
    sum.mls.data <- aggregate(mls.data[, -1], by = list(mls.data$HAULID), sum)
    ## CHECK!! WHEN CHANGES
    sum.mls.data$HAULID <- sum.mls.data$HAULID/20
    ## 
    sum.mls.data.long <- reshape(sum.mls.data, direction = "long", 
                                 drop = c("Group.1"), varying = 2:5, timevar = "Mesh")
    ## net position
    sum.mls.data.long$net.pos <- match(sum.mls.data.long$Mesh, net.position)
    ##
    if(sim.comb$switch[i] == "yes"){
      sum.mls.data.long$net.pos[sum.mls.data.long$HAULID > 5] <- 
        match(sum.mls.data.long$Mesh[sum.mls.data.long$HAULID > 5], rev(net.position))
      ##
      sum.mls.data.long$net.pos <- factor(paste("pos", sum.mls.data.long$net.pos, 
                                                sep =""))
      ##
      ## run the GLMER with position effects 
      mls.glmer <- glmer(count ~ -1 +  Mesh + (1|net.pos), 
                         data = sum.mls.data.long, family = poisson)
      ## plot(unlist(ranef(mls.glmer)))
      null.glmer <- glmer(count ~ (1|net.pos), data = sum.mls.data.long, 
                          family = poisson) 
      ## significance
      (D <- - 2 * logLik(null.glmer) + 2 * logLik(mls.glmer))
      sig <- pchisq(D, lower.tail = FALSE, df = 3)
      ## coefficient values
      coef.hat <- fixef(mls.glmer)[c("Mesh70mm", "Mesh80mm", "Mesh90mm", "Mesh100mm")]
    }else{
      ## run the GLM without position effects 
      mls.glm <- glm(count ~ -1 +  Mesh, data = sum.mls.data.long, family = poisson)
      ##
      null.glm <- glm(count ~ 1, data = sum.mls.data.long, family = poisson) 
      ## significance
      (D <- - 2 * logLik(null.glm) + 2 * logLik(mls.glm))
      sig <- pchisq(D, lower.tail = FALSE, df = 3)      
      ## coefficient values
      coef.hat <- coef(mls.glm)[c("Mesh70mm", "Mesh80mm", "Mesh90mm", "Mesh100mm")]
    }
    if(all(diff(coef.hat) < 0) & sig < 0.05){
      sim.correct[j] <- 1
    }else{
      sim.correct[j] <- 0
    }
  }
  ##
  sim.comb$power[i] <- sum(sim.correct)/nsim
}

save(list = c("sim.comb"), file = "sim_comb.RData")

@ 

<<xtable, results = "asis">>=
load("sim_comb.RData")

sim.comb$gear.effect <- ifelse(sim.comb$p.rfi == "p.rfi.1",
                                     "Equal fishing intensity",
                                     ifelse(sim.comb$p.rfi == "p.rfi.2",
                                            "Single net effect",
                                            "Door effect")
                                     )

sim.comb <- sim.comb[order(sim.comb$p.rfi, sim.comb$net.position), ]

library(xtable)

sim.comb.xtab <- 
  xtable(sim.comb[, c("net.position", "gear.effect", "switch", "power")])

print(sim.comb.xtab, include.rownames = FALSE)

@ 
From these results we can see that:

\begin{itemize}
  \item If the fishing intensity is constant across all the nets (all fishing the same), the power to detect meaningful differences in the numbers caught below the MLS is very high;
  \item If there is a door effect such that the fishing intensity/fishing power decreases or increases across the nets, the power to detect differences will be low without a switch; performing a switch and including the net position as a factor in the analysis results in much improved power to detect;
  \item The most difficult scenario to rectify with the current setup is a single net fishing considerably better than others. Switching does improve this in the random net location by haul but for practical switches it is difficult to isolate what is a gear effect and what is a net effect with a single switch (random effects are assumed symmetric). Additional switches would allow the net position to be included as a fixed effect in the analysis (here they've been necessarily included as a random effect), which may alleviate the issue. This has not been tested here.
\end{itemize}

\bibliography{../../../../misc/epif_bibliography}
\bibliographystyle{../../../../misc/cjfas}
\end{document}












\section{Gear selectivity}
We assume that the gear selection is driven by cod-end retention. We use a logistic selection curve though others can be included (e.g., Richards asymmetric curve).

Convert the lengths to weight (using ICES values here - check), assuming an even sex ratio (revise) (Figure~\ref{fig:lw}).

<<lw, eval = TRUE, fig.align = "center", fig.cap = "Assumed length-weight relationship for \\emph{Nephrops} in the Western Irish Sea.", fig.width = 5, fig.height = 4>>=
a <- (0.00032 + 0.000684) / 2
b <- (3.210 + 2.963) / 2
curve(a * x^b, from = 0, to = 40, bty = "L", 
      xlab = "Carapace length (mm) DOUBLE CHECK", ylab = "Weight (g)")

## in kg
sum(nl.contact * 0.000684 * midpoints^2.963/1e3)

@ 

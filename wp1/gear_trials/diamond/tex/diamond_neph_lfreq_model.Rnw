%% knit("diamond_neph_lfreq_model.Rnw")

\documentclass[12pt]{article}
\usepackage{times}
\usepackage{hyperref}
\hypersetup{pdfpagemode=UseNone} % don't show bookmarks on initial view
\hypersetup{colorlinks, urlcolor={blue}}

% revise margins
\setlength{\headheight}{0.0in}
\setlength{\topmargin}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\textheight}{8.65in}
\setlength{\footskip}{0.35in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\textwidth}{6.5in}

\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}

\title{A model for changes in length frequencies}
\author{}
\date{}

\begin{document}

<<echo=FALSE>>=
library(knitr)
opts_chunk$set(size="footnotesize")
## set the working directory
##setwd('../tex'); 
@

\maketitle

%%\tableofcontents

\section{Data}
Read in length data and modify some column names and variable labels for use below.

<<tidy=TRUE, eval = FALSE, warning = FALSE>>=
library(gdata)

setwd("../data")

neph.dat <- read.xls("Celtic Warrior Diamond mesh July 2014 Celtic Sea.xls", 
                     sheet = "Nephrops Lengths",
                     stringsAsFactors = FALSE)

## Show the first 2 rows
head(neph.dat, 2)

## Change the carapace length name
names(neph.dat)[names(neph.dat) == "Carapace.Length..mm.."] <- "Carapace.Length"

## Make the "HAUL" variable character
neph.dat$HAUL <- paste("H", neph.dat$HAUL, sep ="")
@
%% 
Make one row per length measurement assuming, for example, that a sub-sampling ratio of 0.1 corresponds to 10\% of the catch sampled (CHECK).

<<tidy=TRUE>>=
## get a row per length measurement (raise them also)
n <- nrow(neph.dat)

neph.dat2 <- neph.dat[rep(1:n, times = round(neph.dat$COUNT/neph.dat$SUBSRATIO, 0)), ]
@
%% 

Read in the haul weights
<<tidy=TRUE, eval = FALSE>>=
setwd("../data")

weight.dat <- read.xls("Celtic Warrior Diamond mesh July 2014 Celtic Sea.xls", 
                       sheet = "Weights",
                       stringsAsFactors = FALSE)

## Show the first 2 rows
head(weight.dat, 2)

## create a new "HAUL" variable for the merge
weight.dat$HAUL <- paste("H", weight.dat$Haul.., sep ="")

## re-name total weight column
names(weight.dat)[names(weight.dat) == "Total.weight..kg."] <- "Total.Weight"
@

Merge the bulk weights with the length data
<<tidy = FALSE, eval = FALSE>>=
neph.dat3 <- merge(neph.dat2, 
                   subset(weight.dat, Species == "Bulk")[, c("Mesh.Size", "HAUL", 
                                        "Total.Weight")],
                   by = c("Mesh.Size", "HAUL"))

## subset the data by mesh size
neph.70mm <- subset(neph.dat3, Mesh.Size == "70mm")
neph.80mm <- subset(neph.dat3, Mesh.Size == "80mm")
neph.90mm <- subset(neph.dat3, Mesh.Size == "90mm")
neph.100mm <- subset(neph.dat3, Mesh.Size == "100mm")

## convert HAUL to factor
## with levels depending on the haul weight
neph.70mm$HAUL <- factor(neph.70mm$HAUL, levels = 
                         unique(neph.70mm$HAUL[order(neph.70mm$Total.Weight)]))
neph.80mm$HAUL <- factor(neph.80mm$HAUL, levels = 
                         unique(neph.80mm$HAUL[order(neph.80mm$Total.Weight)]))
neph.90mm$HAUL <- factor(neph.90mm$HAUL, levels = 
                         unique(neph.90mm$HAUL[order(neph.90mm$Total.Weight)]))
neph.100mm$HAUL <- factor(neph.100mm$HAUL, levels = 
                          unique(neph.100mm$HAUL[order(neph.100mm$Total.Weight)]))
@ 


%% 
Produce a summary plot of the data by length, haul and catch weight.
%%
<<fig.width = 5, fig.height = 8, fig.align = "center", warning = FALSE, eval = FALSE, fig.cap = "Stacked carapace length densities. Each haul is coloured according to the total bulk weight in that haul.">>=
library(ggplot2)
library(gridExtra)

## quick function for plot
plot.lfreq <- function(data, title.string){
  p <- ggplot(data, aes(x = Carapace.Length, group = HAUL)) + 
    geom_density(position = "stack", 
                 aes(fill = Total.Weight), 
                 colour = 1, lwd = 0.005) + 
                 xlim(10, 45) + 
                 scale_fill_gradient2(low = "white", high = "blue", 
                                      limits = c(0, max(neph.dat3$Total.Weight))) + 
                 ggtitle(title.string) +
                 theme(axis.text.x=element_blank())
  return(p)
}

p70mm <- plot.lfreq(data = neph.70mm, title.string = "70mm")
p80mm <- plot.lfreq(data = neph.80mm, title.string = "80mm")
p90mm <- plot.lfreq(data = neph.90mm, title.string = "90mm")
p100mm <- plot.lfreq(data = neph.100mm, title.string = "100mm")

grid.arrange(p70mm, p80mm, p90mm, p100mm, ncol = 1)
@

\section{Models}
The first model we'll try is a model assuming all lengths come from a normal distribution with a single mean $\mu$ and standard deviation $\sigma$

\begin{equation}
  l_i \sim \textnormal{N}(\mu, \sigma^2)
\end{equation}

<<fig.height = 4, fig.width = 4, fig.cap = "Histogram of carapace length over all hauls and mesh sizes with overlayed fitted single normal curve.", tidy = TRUE, eval = TRUE, fig.align = "center", warning = FALSE>>=
lm0 <- lm(Carapace.Length ~ 1, data = neph.dat3)

summary(lm0)

## predict the density 
pred.df <- data.frame(Carapace.Length = seq(0, 100))
pred.df$dens <- dnorm(pred.df$Carapace.Length, 
                      mean = coef(lm0)[1], 
                      sd = summary(lm0)$sigma)

## plot the distributional fit
p <- ggplot(neph.dat3, aes(x = Carapace.Length)) + 
  geom_histogram(aes(y = ..density..), fill = "slategrey", color = "white", binwidth = 1) +
  xlim(10, 50)

p + geom_line(data = pred.df, aes(x = Carapace.Length, y = dens))
@ 

This model does not fit the data very well as there are large parts of the distribution not captured.\\
%%
Next model is to let the mean vary by mesh size
<<fig.height = 6, fig.width = 6, fig.cap = "Histogram of carapace length by mesh size with overlayed normal curve with mean varying by mesh size.", tidy = TRUE, eval = TRUE, fig.align = "center", warning = FALSE>>=
lm1 <- lm(Carapace.Length ~ Mesh.Size, data = neph.dat3)

summary(lm1)

## predict the densities
pred.df <- expand.grid(Carapace.Length = seq(0, 100), Mesh.Size = c("70mm", "80mm", "90mm", "100mm"))

pred.df$dens <- dnorm(pred.df$Carapace.Length, 
                      mean = predict(lm1, newdata = pred.df), 
                      sd = summary(lm1)$sigma)

## plot the distributional fit
p <- ggplot(neph.dat3, aes(x = Carapace.Length)) + 
  geom_histogram(aes(y = ..density..), fill = "slategrey", color = "white", binwidth = 1) +  xlim(10, 50) + facet_wrap(~ Mesh.Size)

p + geom_line(data = pred.df, aes(x = Carapace.Length, y = dens))
@ 
Allowing the means to vary by mesh size doesn't fix the lack of distributional fit.\\
The effect of catch weight can be included 
<<tidy = TRUE, eval = TRUE>>=
lm2 <- lm(Carapace.Length ~ Mesh.Size + Total.Weight, data = neph.dat3)
summary(lm2)
## let the total weight effect vary by mesh size
lm3 <- lm(Carapace.Length ~ Mesh.Size + Total.Weight + Mesh.Size:Total.Weight, data = neph.dat3)
summary(lm3)
## test the effect of the interaction between mesh size and length 
anova(lm2, lm3)

hist(resid(lm3), breaks = 100, probability = TRUE, xlim = c(-20, 20))
curve(dnorm(x, mean = 0, sd = summary(lm3)$sigma), add =TRUE)

library(mgcv)
gam2 <- gam(Carapace.Length ~ Mesh.Size + s(log(Total.Weight)), data = neph.dat3)
summary(gam2)
plot.gam(gam2)

gam3 <- gam(Carapace.Length ~ Mesh.Size + s(log(Total.Weight), k = 10, by = as.factor(Mesh.Size)), data = neph.dat3)

summary(gam3)

par(mfrow = c(2, 2))
par(ask = FALSE)
plot(gam3)

neph.dat3$fHAUL <- as.factor(neph.dat3$HAUL)

## include a random haul effect
gamm3 <- gam(Carapace.Length ~ Mesh.Size + 
             s(log(Total.Weight), by = as.factor(Mesh.Size)) +
             s(fHAUL, bs="re"), data = neph.dat3)

summary(gamm3)

par(mfrow = c(3, 2), mar = c(2, 2, 1, 1))
plot(gamm3, scale = 0)

## plot the data

mean.df <- aggregate(Carapace.Length ~ Mesh.Size + Total.Weight, data = neph.dat3, FUN = mean)

ggplot(mean.df, aes(x = Total.Weight, y = Carapace.Length)) + geom_point() + facet_wrap(~ Mesh.Size) + geom_smooth(method = "lm")

## remove haul 12 affects 70mm slightly but the rest still look like the weights affect the mean lengths

## how about the standard deviations?
sd.df <- aggregate(Carapace.Length ~ Mesh.Size + Total.Weight, data = neph.dat3, FUN = sd)

ggplot(sd.df, aes(x = Total.Weight, y = Carapace.Length)) + geom_point() + facet_wrap(~ Mesh.Size) + geom_smooth(method = "lm")

## with the exception of haul 12 for 100mm, the sd looks relatively constant
## so model thus far is mean varying with mesh.size*total.weight, sd constant
## now include the finite mixtures

## in mixtools
library(mixtools)

make.mu.inits <- function(k, data){
  lims <- range(data)
  ## cut the range into k+1 intervals
  brks <- cumsum(c(lims[1], rep((lims[2]-lims[1]) / k, k)))
  mu.start <- sapply(1:k, function(zz){
    runif(1, min = brks[zz], max = brks[zz+1])
  })
  return(mu.start)
}

## 10 restarts 
m <- 10
my.k <- 4

set.seed(101)
fit1 <- normalmixEM(neph.70mm$Carapace.Length, k=my.k, mu = make.mu.inits(my.k, data = neph.70mm$Carapace.Length), sigma = rep(2, my.k), epsilon = 1e-4)

fit.df <- matrix(ncol = 3 * my.k + 1, nrow = m)
fit.df[1, ] <- c(fit1$lambda, fit1$mu, fit1$sigma, fit1$loglik)

## should increase the number of iterations
for(i in 2:m){
  print(i)
  fit <- normalmixEM(neph.70mm$Carapace.Length, k=my.k, mu = make.mu.inits(my.k, data = neph.70mm$Carapace.Length), sigma = rep(2, my.k), epsilon = 1e-4)
  ##
  fit.df[i, ] <- c(fit$lambda, fit$mu, fit$sigma, fit$loglik)
  rm(fit)
}

## loglik 
plot(fit.df[, 3*my.k + 1], type = "o")
## lambda
matplot(fit.df[, 1:my.k], lty =1, type = "o")
## mu
matplot(fit.df[, (my.k+1):(2*my.k)], lty =1, type = "o")
## sigma
matplot(fit.df[, (2*my.k+1):(3*my.k)], lty =1, type = "o")



## how many components?
## this picked three components
mix.comp <- boot.comp(y = neph.70mm$Carapace.Length, max.comp = 5, B = 5, mix.type = "normalmix", verb = FALSE, epsilon = 1e-1)

## how about flexmix?
## can't supply explicit starting values
library(flexmix)

inits <- initFlexmix(neph.70mm$Carapace.Length ~ 1, k = 1:6, nrep =5)

flex.comp <- stepFlexmix(neph.70mm$Carapace.Length ~ 1, k = 1:6, nrep =5)

best.flex <- getModel(flex.comp, "AIC")

xx <- seq(0, 100, length = 1000)
ncomp <- dim(parameters(best.flex))[2]
pred.dens <- matrix(nrow = ncomp, ncol = length (xx))
for(i in 1:ncomp){
  pars <- parameters(best.flex, component = i)
  pred.dens[i, ] <- best.flex@prior[i] * dnorm(xx, mean = pars[1], sd = pars[2])
}

hist(neph.70mm$Carapace.Length, breaks = seq(0,100), xlim = range(neph.70mm$Carapace.Length), col = "lightgrey", border="grey", probability = TRUE)
matlines(xx, t(pred.dens), lty = 1, col = "red")
lines(xx, apply(pred.dens, 2, sum), col ="green", lwd = 2)

## library(gamlss) ## too slow but could be flexible

@ 



\end{document}

